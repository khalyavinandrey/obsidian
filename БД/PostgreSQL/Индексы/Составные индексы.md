Нужно разместить столбцы в правильном порядке:
вначале лучше самый селективный столбец

сканируемая область индекса определяется условиями равенства с ведущими столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства
Например, если есть индекс по столбцам `(a, b, c)` и условие `WHERE a = 5 AND b >= 42 AND c < 77`, индекс будет сканироваться от первой записи `a` = 5 и `b` = 42 до последней с `a` = 5. Записи индекса, в которых `c` >= 77, не будут учитываться, но тем не менее будут просканированы. Этот индекс в принципе может использоваться в запросах с ограничениями по `b` и/или `c`, без ограничений столбца `a`, но при этом будет просканирован весь индекс, так что в большинстве случаев планировщик предпочтёт использованию индекса полное сканирование таблицы.

Равенство + неравенство >> неравенство
Плохой индекс может работать медленнее чем запрос без индекса

в первую очередь в составном индексе нужно указывать поля из условия _WHERE_, а во второй — из сортировки _ORDER BY_.

порядок полей из условия WHERE зависит от того, сколько вариантов значений может принимать поле, чем больше — тем первее.

- Использование составных индексов значительно ускоряет работу базы данных на сложных условиях;
- Уникальные поля желательно ставить в конце составного индекса;
- В первую очередь идут поля из условия _WHERE_, потом из сортировки _ORDER BY_;
    - Поля из условия _WHERE_ указывать в порядке — сначала поля с большими вариантами принимаемых значений, потом с меньшими;
    - Поля из сортировки _ORDER BY_ — в соответствии с порядком сортировки;
- По возможности делать частичные индексы, то есть в индексе должны быть только те данные, которые мы будем реально выбирать;

#бд 
#postgresql 
#индексы
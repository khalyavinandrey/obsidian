Цель - превратить произвольный доступ ключей с диска в последовательное чтение ключей с диска
![[Pasted image 20240730202220.png]]
Индексный файл перечисляет ключи в файле данных по порядку, указывая для каждого ключа его положение в файле данных.

Сводный файл SSTable хранится в памяти и содержит образцы ключей для быстрого поиска в индексном файле. По сути, это индекс для индексного файла SSTable. Для поиска определенного ключа сначала обращаются к сводному файлу, чтобы найти короткий диапазон позиций, в которых можно найти ключ, и загружает это конкретное смещение в память.
Сводный файл SSTable хранится в памяти и содержит образцы ключей для быстрого поиска в индексном файле. По сути, это индекс для индексного файла SSTable. Для поиска определенного ключа сначала обращаются к сводному файлу, чтобы найти короткий диапазон позиций, в которых можно найти ключ, и загружает это конкретное смещение в память

![[Pasted image 20240730202510.png]]
1) Get, durability, immutable -> sstable (sorted string table)
2) fast put -> append log
3) fast get -> memtable. put(log) + put(memtable)
тк get может быть слишком долгим: если много sstables -> sstable объединяются, сначала поиск в memtable - потом поиск в sstable, данные лежат последовательными пачками на диске, sstable - иммутабельны
![[Pasted image 20240730204008.png]]

как происходит delete? - это put(key, tombstone) и при слиянии sstables старая запись удаляется а в объединенной sstable лежит key, tombstone